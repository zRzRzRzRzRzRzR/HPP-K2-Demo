<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Causal Network (with Node Info Panel)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* ===== Base Styles ===== */
    html, body { height: 100%; }
    body { margin: 0; background: #000; color: #eee; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif; }
    #3d-graph { position: fixed; inset: 0 360px 0 0; } /* Reserve space for panel (360px) */

    /* ===== Node Info Panel ===== */
    #node-panel.panel {
      position: fixed; top: 0; right: 0;
      width: 360px; max-width: 85vw; height: 100vh;
      background: rgba(20,20,20,0.96);
      color: #eee; overflow-y: auto; padding: 16px 20px 24px;
      box-shadow: -12px 0 24px rgba(0,0,0,0.4);
      backdrop-filter: blur(4px);
      z-index: 10;
    }
    #node-panel.hidden { display: none; }
    #panel-close {
      position: absolute; top: 10px; right: 10px;
      background: transparent; color: #aaa; border: 0; font-size: 18px; cursor: pointer;
    }
    #node-panel h2 { margin: 8px 0 6px; font-size: 18px; color: #fff; }
    #node-panel a { color: #7dcfff; word-break: break-all; }
    #node-panel .meta { font-size: 12px; color: #bbb; margin-bottom: 12px; }
    #node-panel .pill {
      display: inline-block; padding: 2px 8px; border: 1px solid #555;
      border-radius: 999px; margin: 0 8px 8px 0; font-size: 12px; color:#ddd;
    }
    
    /* ===== Recursive Function CSS (Optional but recommended) ===== */
    #panel-content ul {
      margin: 4px 0; 
      padding-left: 20px;
      list-style-type: none;
    }
    #panel-content ul li {
      padding: 2px 0;
      font-size: 14px;
    }
    #panel-content ul li strong {
      color: #88cfff; /* Light blue for keys */
      margin-right: 6px;
    }
    #panel-content ul ul {
      list-style-type: disc; /* Indent nested lists */
    }


    /* On small screens, make graph fullscreen and panel overlay */
    @media (max-width: 768px) {
      #3d-graph { inset: 0; }
      #node-panel.panel { width: 85vw; }
    }
  </style>

  <script src="//cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <div id="3d-graph"></div>

  <div id="node-panel" class="panel hidden">
    <button id="panel-close">✕</button>
    <div id="panel-content"></div>
  </div>

  <script type="module">
    import SpriteText from "https://esm.sh/three-spritetext";

    // ========= Group Colors: Automatic =========
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    let hoverNode = null;

    const Graph = new ForceGraph3D(document.getElementById('3d-graph'))
      .backgroundColor('#000')
      .linkDirectionalArrowLength(3.5)
      .linkDirectionalArrowRelPos(1)
      .linkCurvature(0.25)
      .linkDirectionalParticles(link => highlightLinks.has(link) ? 4 : 0)
      .linkDirectionalParticleWidth(4)
      .nodeAutoColorBy('group') // Automatically color by 'group'
      .linkWidth(link => highlightLinks.has(link) ? 4 : 1)
      .nodeThreeObject(node => {
        const sprite = new SpriteText(String(node.id));
        sprite.material.depthWrite = false;
        sprite.color = node.color; // Set by nodeAutoColorBy
        sprite.textHeight = 8;
        sprite.center.y = -0.6;
        return sprite;
      })
      .nodeThreeObjectExtend(true);

    // === Hover Interaction (Node) ===
    Graph.onNodeHover(node => {
      if ((!node && !highlightNodes.size) || node === hoverNode) return;

      highlightNodes.clear();
      highlightLinks.clear();
      if (node) {
        highlightNodes.add(node);
        node.neighbors?.forEach(nei => highlightNodes.add(nei));
        node.links?.forEach(l => highlightLinks.add(l));
      }
      hoverNode = node || null;
      updateHighlight();
    });

    // === Hover Interaction (Link) ===
    Graph.onLinkHover(link => {
      highlightNodes.clear();
      highlightLinks.clear();
      if (link) {
        highlightLinks.add(link);
        highlightNodes.add(link.source);
        highlightNodes.add(link.target);
      }
      updateHighlight();
    });

    function updateHighlight() {
      Graph
        .nodeColor(node => {
          if (highlightNodes.has(node)) {
            return node === hoverNode ? '#ff0000' : '#ffa000';
          }
          return node.color;
        })
        .linkWidth(Graph.linkWidth())
        .linkDirectionalParticles(Graph.linkDirectionalParticles());
    }

    // ====== 辅助函数：将对象递归转换为 HTML 列表 ======
    // (这是我们新添加的函数)
    function objectToHtml(obj) {
      // 基本类型 (string, number, boolean) 或 null
      if (obj === null) return '<em>null</em>';
      if (typeof obj !== 'object') return String(obj);

      // --- 如果是数组 ---
      if (Array.isArray(obj)) {
        let listHtml = '<ul>';
        // 遍历数组中的每一项
        obj.forEach(item => {
          listHtml += `<li>${objectToHtml(item)}</li>`; // 递归调用
        });
        listHtml += '</ul>';
        return listHtml;
      }

      // --- 如果是对象 ---
      let html = '<ul>';
      // 遍历对象中的每一个键值对
      for (const [key, value] of Object.entries(obj)) {
        html += `<li><strong>${key}:</strong> `;
        html += objectToHtml(value); // 递归调用
        html += '</li>';
      }
      html += '</ul>';
      return html;
    }

    // ====== Info Panel Logic ======
    const panelEl = document.getElementById('node-panel');
    const panelContentEl = document.getElementById('panel-content');
    document.getElementById('panel-close').onclick = () => panelEl.classList.add('hidden');

    //
    // --- THIS IS THE MODIFIED FUNCTION (Method 2: Recursive) ---
    //
    function showNodeInfo(node) {
      
      if (node.content) {
        
        const contentType = typeof node.content;

        if (contentType === 'string') {
          // 1. 如果 content 是字符串, 直接使用
          panelContentEl.innerHTML = node.content;

        } else if (contentType === 'object' && node.content !== null) {
          // 2. 如果 content 是对象, 使用 objectToHtml 自动构建
          
          const autoGeneratedHtml = objectToHtml(node.content);

          panelContentEl.innerHTML = `
            <h2>${node.id}</h2>
            <div class="meta">
              <span class="pill">Group: ${node.group ?? 'N/A'}</span>
            </div>
            <hr style="border-color: #444; margin: 16px 0;">
            ${autoGeneratedHtml}
          `;
          
        } else {
          // 3. 备用情况
          panelContentEl.innerHTML = `<p>Error: Unknown content format.</p>`;
        }

      } else {
        
        // --- 原始的备用逻辑 ---
        const degree = node.neighbors ? node.neighbors.length : 0;
        const title = node.title || String(node.id);
        const desc = node.desc || '';
        const url = node.url;

        panelContentEl.innerHTML = `
          <h2>${title}</h2>
          <div class="meta">
            <span class="pill">id: ${String(node.id)}</span>
            <span class="pill">group: ${node.group ?? '-'}</span>
            <span class="pill">degree: ${degree}</span>
          </div>
          ${desc ? `<p>${desc}</p>` : ''}
          ${url ? `<p><a href="${url}" target="_blank" rel="noopener">More Info ↗</a></p>` : ''}
        `;
      }

      panelEl.classList.remove('hidden');
    }

    // ====== Node Click: Show Info + Focus Camera ======
    Graph.onNodeClick(node => {
      // Show info panel
      showNodeInfo(node);

      // Focus camera
      const distance = 300; // Camera distance from target
      const distRatio = 1 + distance / Math.hypot(node.x || 0, node.y || 0, node.z || 0);
      const newPos = (node.x || node.y || node.z)
        ? { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }
        : { x: 0, y: 0, z: distance };

      Graph.cameraPosition(newPos, node, 3000);
    });

    // Click background to hide panel (optional)
    Graph.onBackgroundClick(() => panelEl.classList.add('hidden'));

    // ====== Load Data -> Build Adjacency -> Render ======
    
    // --- IMPORTANT ---
    // 确保 'hpp_causal_network_dense2.json' 和这个 HTML 文件在同一个文件夹中
    fetch('hpp_causal_network_fixed.json')
      .then(r => r.json())
      .then(data => {
        const nodeById = new Map(data.nodes.map(n => [n.id, n]));
        data.nodes.forEach(n => { n.neighbors = []; n.links = []; });
        data.links.forEach(l => {
          const a = typeof l.source === 'object' ? l.source : nodeById.get(l.source);
          const b = typeof l.target === 'object' ? l.target : nodeById.get(l.target);
          if (!a || !b) return;
          a.neighbors.push(b); b.neighbors.push(a);
          a.links.push(l);    b.links.push(l);
        });

        Graph.graphData(data);
        Graph.d3Force('charge').strength(-400);
      });
  </script>
</body>
</html>